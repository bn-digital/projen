import { DependencyType, javascript, ObjectFile, Project, ProjectOptions, Task } from "projen"import * as components from "../../components"import { defaultLinterOptions } from "../../components/ide"import { PackageJsonFile } from "../../components/node"export interface BrandNewProjectOptions  extends ProjectOptions,    components.docker.DockerProjectOptions,    components.ide.LintersProjectOptions,    components.helm.HelmProjectOptions {  readonly graphql?: components.graphql.GraphqlOptions  readonly deps?: string[]  readonly devDeps?: string[]  readonly packageManager?: javascript.NodePackageManager  readonly packageName?: string}/** * @pjid brand-new */export class BrandNewProject extends Project {  /**   * @default {}   */  readonly docker: components.docker.Docker | undefined  readonly helm: components.helm.Helm | undefined  readonly graphql: components.graphql.Graphql | undefined  readonly linters: components.ide.Linters | undefined  /**   * @default "yarn2"   */  readonly packageManager?: javascript.NodePackageManager  readonly yarn: components.node.Yarn | undefined  constructor(options: BrandNewProjectOptions) {    const {      linters,      docker,      helm = {},      graphql,      ...initialOptions    } = BrandNewProject._withSanitizedInputs(BrandNewProject._withDefaults(options))    super(initialOptions)    this.yarn = new components.node.Yarn(this, { private: true })    this.packageJson?.addOverride("name", this.packageName)    options.deps?.forEach(it => this.deps.addDependency(it, DependencyType.RUNTIME))    options.devDeps?.forEach(it => this.deps.addDependency(it, DependencyType.DEVENV))    if (!this.parent) {      if (linters) this.linters = new components.ide.Linters(this, linters)      this.defaultTask?.prependExec("npx projen install")    }    if (docker) this.docker = new components.docker.Docker(this)    if (helm) this.helm = new components.helm.Helm(this, helm)    if (graphql) this.graphql = new components.graphql.Graphql(this, options.graphql)  }  get packageName(): string {    return this.parent ? `@${this.parent.name}/${this.name}` : this.name  }  get packageJson(): ObjectFile | undefined {    return this.tryFindObjectFile(PackageJsonFile.FILENAME)  }  get installTask(): Task | undefined {    return this.tasks.tryFind("install")  }  /**   * @internal   */  protected static _withDefaults<T extends BrandNewProjectOptions & unknown>(options: T): T {    const {      name,      commitGenerated = false,      projenrcJson = true,      parent,      linters = defaultLinterOptions,      packageName = name,      packageManager = javascript.NodePackageManager.YARN2,    } = options    return {      ...options,      name,      commitGenerated,      parent,      linters,      outdir: options.outdir || !parent ? options.outdir : `packages/${name}`,      projenrcJson,      packageManager,      packageName,    }  }  private static _withSanitizedInputs<T extends BrandNewProjectOptions & unknown>({ name, parent, ...options }: T): T {    name = BrandNewProject._slugify(name)    return {      name: BrandNewProject._slugify(name),      packageName: parent ? [`@${parent?.name}`, name].map(it => BrandNewProject._slugify(it)).join("/") : name,      outdir: options.outdir        ?.split("/")        .map(it => BrandNewProject._slugify(it))        .join("/"),      parent,      ...options,    } as T  }  private static _slugify(string: string): string {    return string      .replace(/([a-z])([A-Z])/g, "$1-$2")      .replace(/[\s_]+/g, "-")      .toLowerCase()  }  /**   * @inheritDoc   */  preSynthesize() {    super.preSynthesize()    this.packageJson?.addOverride("dependencies", this._dependencyMap(DependencyType.RUNTIME, DependencyType.BUILD))    this.packageJson?.addOverride("devDependencies", this._dependencyMap(DependencyType.DEVENV))    this.packageJson?.addOverride("peerDependencies", this._dependencyMap(DependencyType.PEER))    this.packageJson?.addOverride("bundledDependencies", this._dependencyMap(DependencyType.BUNDLED))  }  /**   * @inheritDoc   */  synth() {    super.synth()  }  /**   * @param {DependencyType[]} deps   * @internal   */  private _dependencyMap(...deps: DependencyType[]): Record<string, string> {    return this.deps.all      .filter(it => deps.some(that => that === it.type))      .map(value => ({ [value.name]: value.version ?? "*" }))      .reduce((each, all) => ({ ...all, ...each }), {})  }}